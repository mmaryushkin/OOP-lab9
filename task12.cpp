#include <iostream>

using namespace std;

/* 
    Объектно-ориентированное программирование без хуйни:

    Короче блять, я нихуя не понял то, что написал Лафоре в учебнике, по-моему там даже были 
    вещи, которые не стыкуются. НО! Насколько я понял, симуляция памяти и адресов с указателями 
    в этой проге должна работать следующим образом:

    У нас есть массив fmemory, в нем будут хранится значения типа float.
    В массиве pmemory будут хранится индексы на значения массива fmemory, именно эти индексы будут
    использоваться как указатели.
    fmem_top - это индекс массива fmemory, он показывает какой элемент массива свободен
    аналогично с pmem_top

    Далее нам нужно создать класс Float. В этом классе у нас есть поле addr, которое в учебнике
    Лафоре сначала объявляется как "индекс массива fmemory", а затем магическим образом превращается
    в массив, хотя мб я долбаеб и чего-то не понял.

    КРЧ я использовал addr как поле типа int, для хранения индекса (т.е адреса) значения из
    массива fmemory. Как я его использовал? Конструктор принимает в аргумент значение типа float,
    это значение я сохраняю в массив fmemory по индексу fmem_top, затем в поле addr я записываю
    значение индекса fmem_top, чтобы не потерять адрес аргумента и последним действием увеличиваю
    fmem_top на 1, чтобы записывать новые значения в массив fmemory.
    Резюмируем: в конструкторе аргумент кладется в массив, а индекс сохраняется в поле addr, чтобы
    в дальнейшем использоваться как адрес элемента массива.

    Далее у нас идет метод перегруженной операции &. Оригинальная опреация возвращает адрес элемента
    в памяти. В нашем случае адрес - это индекс массива fmemory, который мы сохранили в поле addr,
    поэтому по логике вещей мы должны вернуть из метода значение addr.

    Потом мы создаем второй класс ptrFloat. Это класс, который иммитирует поведение указателя.
    Из учебника Лафоре я нихуя не понял, но сам че то написал. Я рассуждал так:
    Если обычный указатель инициализируется с помощью адреса, то и этот наш класс в качестве
    аргумента конструктора должен принимать на вход адрес. Далее - как работает указатель? Сам
    указатель хранит в себе значение адреса, а разыменованный указатель возвращает значение по этому
    адресу. За хранение значений отвечает массив fmemory, за хранение адресов значений отвечает 
    массив pmemory. Следовательно, если наш класс ptrFloat должен принимать в конструкторе адрес, 
    то он должен сохранять его в массив pmemory, поэтому в pmemory я кладу адрес числа по индексу
    pmem_top, а в поле addr сохраняю сам индекс pmem_top.

    И в перегруженном операторе * нам нужно вернуть значение из массива fmemory. Получается, что
    addr - это индекс указателя на значение в массиве fmemory. То есть для начала нам нужно получить
    указатель, а он находится в pmemory[addr], а затем получить само значение, а оно находится в
    fmemory[pmemory[addr]].

    Че получаем в итоге? Я переписал функцию main из упражнения и вроде бы она работает как надо,
    но я не уверен какие есть подводные камни в моей программе.
    
    Кароче блять еще раз резюмируем, а то блять развел тут демагогию:
    Класс Float принимает значение типа float, сохраняет его в массив fmemory и сохраняет адрес (индекс)
    элемента в поле addr. Операция & возвращает этот адрес.

    Класс strFloat принимает значение типа int, которое используется в программе, как адрес.
    Адрес сохраняется в массив pmemory, а индекс адреса сохраняется в поле класса addr.
    Операция * возвращает значение из массива fmemory, взятое по индексу addr из массива pmemory.
 
    
    Вроде все блять. Понятно, что нихуя не понятно. Крч надеюсь, что у меня все верно
    и что я доходчиво объяснил. Если найдете ошибки, то пж маякните. 
    Задача блять разрывная просто.
*/

const int size = 100;
float fmemory[size];  // массив для хранения значений типа float
int pmemory[size];  // адреса на значения указателей
int fmem_top;  // следующее по очереди доступное место
int pmem_top;


class Float {

private:
    int addr;  // адрес элемента массива

public:
    Float(float value) {
        fmemory[fmem_top] = value;  // сохраняем значение в массиве
        addr = fmem_top++;  // в адрес сохраняем индекс массива; инкременируем индекс
    }

    int operator&() {
        return addr;  // возвращаем адрес массива
    }
};


class prtFloat {

private:
    int addr;  // индекс указателя

public:
    prtFloat(int a) {  // получаем адрес
        pmemory[pmem_top] = a;  // сохраняем адрес в массив указателей
        addr = pmem_top++;  // сохраняем индекс указателя; инкременируем индекс 
    }

    float& operator*() {
        return fmemory[pmemory[addr]];  // в массиве pmemory под индексом addr лежит указатель на значение float в массиве fmemory
    }
}; 


int main() {
    Float f1 = 1.234;
    Float f2 = 5.678;

    prtFloat p1 = &f1;  // создаем указатель на f1
    prtFloat p2 = &f2;  // создаем указатель на f2

    cout << *p1 << "\n" << *p2 << endl;  // разыменовывем p1 и p2
    *p1 = 7.123;  // меняем значение p1 по указателю
    *p2 = 8.456;  // меняем значение p2 по указателю
    cout << *p1 << "\n" << *p2 << endl;

    return 0;
}
