#include <iostream>

using namespace std;

/*
    * 9. Допустим, что нам нужно сохранить 100 целых чисел так, чтобы иметь к ним легкий доступ. 
    * Допустим, что при этом у нас есть проблема: память нашего компьютера так фрагментирована, 
    * что может хранить массив, наибольшее количество элементов в котором равно десяти 
    * (такие проблемы действительно появляются, хотя обычно это происходит с объектами, 
    * занимающими большое количество памяти). Вы можете решить эту проблему, определив 10 
    * разных массивов по 10 элементов в каждом и массив из 10 указателей на эти массивы. 
    * Массивы будут иметь имена а0, a1, а2 и т. д. Адрес каждого массива будет сохранен в массиве 
    * указателей типа int*, который называется ар. Вы сможете получить доступ к отдельному 
    * целому используя выражение ap[j] [к], где j является номером элемента массива указателей, 
    * а к — номером элемента в массиве, на который этот указатель указывает. Это похоже на 
    * двумерный массив, но в действительности является группой одномерных массивов.
    * Заполните группу массивов тестовыми данными (скажем, номерами 0, 10, 20 и т. д.), а затем 
    * выведите их, чтобы убедиться, что все работает правильно.
*/


int main() {
    const int size = 10;
    int a0[size], a1[size], a2[size], a3[size], a4[size], a5[size], a6[size], a7[size], a8[size], a9[size];
    int* ap[size] = { a0, a1, a2, a3, a4, a5, a6, a7, a8, a9 };  // массив с указателями на массивы

    // заполнение массивов значениями от 0 до 99
    int p = 0;  // порядок десятков
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size; j++) {
            ap[i][j] = p + j;
        }
        p += 10;  // увеличение порядка десятков
    }

    // вывод данных на экран
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < size; j++)
            cout << ap[i][j] << " ";
        cout << "\n";
    }

    return 0;
}
